<p>피자들을 위한 일정관리 시스템(여러 명이 참여하는 일정 조율 서비스)에서 가장 중요한 기능 중 하나는 
<strong>“가장 많은 피자가 참석할 수 있는 시간은 언제인가?”</strong>를 명확하게 알려주는 기능이다
(<del>아니면 피자들이 카카오톡 투표 기능이 더 편하다고 불평할게 뻔함</del>)</p>
<p><strong>여러 참가자의 가능 시간을 분석해 최적의 시간대를 추천하는 알고리즘</strong>을 이 시스템에서 어떻게 적용했는지 적어보겠다!
<img alt="" src="https://velog.velcdn.com/images/sommnie/post/d374e875-d569-4c7e-9b76-2252ffc86bb0/image.jpg" /></p>
<h4 id="🎯-목표-여러-참가자의-가능-시간을-분석하여-가장-많은-사람이-참석-가능한-시간대를-추천">🎯 목표: 여러 참가자의 가능 시간을 분석하여 가장 많은 사람이 참석 가능한 시간대를 추천</h4>
<h3 id="⏱-시간-복잡도">⏱ 시간 복잡도</h3>
<p><strong>O(N × M)</strong></p>
<ul>
<li><strong>N</strong>: 타임슬롯 개수  </li>
<li><strong>M</strong>: 평균 참가자당 가능 시간 개수  </li>
</ul>
<h3 id="1️⃣-데이터-수집-하기">1️⃣ 데이터 수집 하기</h3>
<pre><code class="language-python"># 이벤트의 모든 타임슬롯 가져오기
time_slots = TimeSlot.objects.filter(event=event).order_by('start_datetime')

# 이벤트의 전체 참가자 수
total_participants = Participant.objects.filter(event=event).count()</code></pre>
<p>먼저 이벤트에 속한 모든 시간 후보(타임슬롯)을 시작 시간 기준으로 정렬 한 다음 이벤트에 참여한 총 참가자 수를 계산했다</p>
<p>예를 들면
타임슬롯이
<em>[1월 9일 14시, 1월 9일 15시, … , 1월 11일 17시] _
이렇게 있다고 정렬하면
참가자 수는 
_6명 (어이, 바오, 윙, 듀, 존핑, 조나나)</em> 계산!!</p>
<h3 id="2️⃣-참가자-집계-알고리즘">2️⃣ 참가자 집계 알고리즘</h3>
<pre><code class="language-python">for slot in time_slots:
    available_participants = ParticipantAvailability.objects.filter(
        time_slot=slot,
        is_available=True
    ).select_related('participant')

    available_count = available_participants.count()
</code></pre>
<p>각 타임 슬롯마다 <strong>가능</strong>으로 체크 한 참가자만 조회하고</p>
<pre><code class="language-python">select_related('participant')</code></pre>
<p>로 N+1 쿼리 문제 방지했다!!</p>
<p>예를들면
ParticipantAvailability 테이블이 이렇게 있다고 가정하면</p>
<table>
<thead>
<tr>
<th>participant_id</th>
<th>time_slot_id</th>
<th>is_available</th>
</tr>
</thead>
<tbody><tr>
<td>1 (철수)</td>
<td>101</td>
<td>True</td>
</tr>
<tr>
<td>2 (영희)</td>
<td>101</td>
<td>True</td>
</tr>
<tr>
<td>1 (철수)</td>
<td>102</td>
<td>False</td>
</tr>
<tr>
<td>2 (영희)</td>
<td>102</td>
<td>True</td>
</tr>
</tbody></table>
<p>슬롯 101 → 2명 가능</p>
<p>슬롯 102 → 1명 가능</p>
<h3 id="3️⃣-필터링-추가">3️⃣ 필터링 추가</h3>
<pre><code class="language-python">if min_participants and available_count &lt; min_participants:
    continue</code></pre>
<p>사용자가 최소 참석 인원을 지정한 경우 해당 조건을 만족하지 못하는 슬롯은 제거하도록 필터링을 추가했다!!!!!!</p>
<h3 id="4️⃣-메타데이터-계산">4️⃣ 메타데이터 계산</h3>
<pre><code class="language-python">participant_names = [
    avail.participant.nickname
    for avail in available_participants
]

percentage = (
    available_count / total_participants * 100
) if total_participants &gt; 0 else 0
</code></pre>
<p>해당 시간대에 참석 가능한 참가자 이름 리스트를 뽑은 다음에 참석률(%)을 계산했다</p>
<ul>
<li>참석률 계산 : (가능한 인원 / 총 인원) * 100</li>
</ul>
<p>예를 들면</p>
<p>5명 중 5명 가능 → 100% -&gt; 당첨
5명 중 3명 가능 → 60%
5명 중 1명 가능 → 20%</p>
<h3 id="5️⃣-정렬-알고리즘">5️⃣ 정렬 알고리즘</h3>
<p><img alt="" src="https://velog.velcdn.com/images/sommnie/post/1b4b0f06-e1f5-4ef5-82f0-8f8693b5f9d3/image.jpg" /></p>
<p>가능한 참가자 수로 내림차순 정렬 진행!!</p>
<pre><code class="language-python">slot_recommendations.sort(
    key=lambda x: x['available_count'],
    reverse=True
)
</code></pre>
<p>Python의 list.sort()와 sorted()는 내부적으로 Timsort 알고리즘을 사용할거다</p>
<ul>
<li>시간 복잡도: O(N log N)</li>
<li>key: 정렬 기준 → available_count(가능한 참가자 수)</li>
<li>reverse=True: 많은 인원 순서대로 정렬 (내림차순)</li>
</ul>
<p>정렬 전 / 후 를 비교해보자면
정렬 전:</p>
<pre><code>[슬롯1: 1명,
 슬롯2: 2명,
 슬롯3: 4명,
 슬롯4: 5명,
 슬롯5: 3명]
</code></pre><p>이 상태에서는 어떤 슬롯이 최적인지 한눈에 보기 어렵다</p>
<p>정렬 후:</p>
<pre><code>[슬롯4: 5명 ← 1위
 슬롯3: 4명 ← 2위
 슬롯5: 3명 ← 3위
 슬롯2: 2명 ← 4위
 슬롯1: 1명 ← 5위]</code></pre><p>한 눈에 보기 쉬움</p>
<h3 id="6️⃣-상위-n개-선택">6️⃣ 상위 N개 선택</h3>
<pre><code class="language-python">recommended_slots = slot_recommendations[:limit]
</code></pre>
<ul>
<li>정렬된 리스트에서 앞에서부터 limit개만 슬라이싱</li>
<li>기본값: 5개</li>
<li>사용자 지정 기능</li>
</ul>
<p>만약에 limit = 3인 경우</p>
<pre><code class="language-python">[5명, 4명, 3명]
# 이렇게 출력된다</code></pre>
<h3 id="7️⃣-메시지-생성-로직">7️⃣ 메시지 생성 로직</h3>
<pre><code class="language-python">if not recommended_slots:
    message = &quot;조건에 맞는 추천 시간이 없습니다&quot;
elif recommended_slots[0]['available_count'] == total_participants:
    all_available_count = len(
        [s for s in recommended_slots if s['available_count'] == total_participants]
    )
    message = f&quot;모든 참가자가 가능한 시간이 {all_available_count}개 있습니다&quot;
else:
    top_count = recommended_slots[0]['available_count']
    message = f&quot;최대 {top_count}명의 참가자가 가능한 시간입니다&quot;
</code></pre>
<p>조건부 로직:</p>
<ol>
<li>추천 시간이 0개 인 경우: min_participants 필터로 모두 제외됨</li>
<li>전원 참석 가능한 시간이 있는 경우: </li>
</ol>
<ul>
<li>1위 시간의 참가자 수 == 총 참가자 수</li>
<li>전원 가능한 시간이 여러개 일 수도 있으니까 개수 계산</li>
</ul>
<p>3.일부만 가능 한 경우: 최대 몇명까지 가능한지 표시</p>
<p><strong>타임슬롯 별 가능여부 확인</strong></p>
<table>
<thead>
<tr>
<th>슬롯</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>합계</th>
</tr>
</thead>
<tbody><tr>
<td>9일 14시</td>
<td>✅</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><strong>1명</strong></td>
</tr>
<tr>
<td>9일 15시</td>
<td>&nbsp;</td>
<td>✅</td>
<td>✅</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td><strong>2명</strong></td>
</tr>
<tr>
<td>9일 16시</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>&nbsp;</td>
<td><strong>4명</strong></td>
</tr>
<tr>
<td>9일 17시</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td><strong>5명 ⭐</strong></td>
</tr>
<tr>
<td>9일 18시</td>
<td>&nbsp;</td>
<td>✅</td>
<td>&nbsp;</td>
<td>✅</td>
<td>✅</td>
<td><strong>3명</strong></td>
</tr>
</tbody></table>
<p><strong>단계별 처리</strong></p>
<pre><code class="language-json"># Step 1: 각 슬롯의 가능 인원 집계
  {
    &quot;9일14시&quot;: {&quot;count&quot;: 1, &quot;people&quot;: [&quot;A&quot;]},
    &quot;9일15시&quot;: {&quot;count&quot;: 2, &quot;people&quot;: [&quot;B&quot;, &quot;C&quot;]},
    &quot;9일16시&quot;: {&quot;count&quot;: 4, &quot;people&quot;: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]},
    &quot;9일17시&quot;: {&quot;count&quot;: 5, &quot;people&quot;: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]},
    &quot;9일18시&quot;: {&quot;count&quot;: 3, &quot;people&quot;: [&quot;B&quot;, &quot;D&quot;, &quot;E&quot;]}
  }

  # Step 2: 가능 인원으로 정렬
  [
    {&quot;count&quot;: 5, &quot;slot&quot;: &quot;9일17시&quot;},  # 1위
    {&quot;count&quot;: 4, &quot;slot&quot;: &quot;9일16시&quot;},  # 2위
    {&quot;count&quot;: 3, &quot;slot&quot;: &quot;9일18시&quot;},  # 3위
    {&quot;count&quot;: 2, &quot;slot&quot;: &quot;9일15시&quot;},  # 4위
    {&quot;count&quot;: 1, &quot;slot&quot;: &quot;9일14시&quot;}   # 5위
  ]

  # Step 3: 상위 3개 선택 (limit=3)
  [
    {&quot;count&quot;: 5, &quot;slot&quot;: &quot;9일17시&quot;, &quot;percentage&quot;: 100.0},
    {&quot;count&quot;: 4, &quot;slot&quot;: &quot;9일16시&quot;, &quot;percentage&quot;: 80.0},
    {&quot;count&quot;: 3, &quot;slot&quot;: &quot;9일18시&quot;, &quot;percentage&quot;: 60.0}
  ]</code></pre>
<hr />
<h2 id="🕰️-시간--공간-복잡도-분석">🕰️ 시간 / 공간 복잡도 분석</h2>
<h3 id="시간-복잡도">시간 복잡도</h3>
<p><strong>O(N × M + N log N)</strong></p>
<p>N = 타임슬롯 개수
M = 평균 슬롯당 가능 참가자 수</p>
<pre><code>- 슬롯 순회: O(N)
- 각 슬롯의 참가자 조회: O(M)
- 정렬: O(N log N)
- 상위 선택: O(1)</code></pre><h3 id="공간-복잡도">공간 복잡도</h3>
<p><strong>O(N × M)</strong>
모든 슬롯의 추천 데이터 저장</p>
<p>실제 성능으로는
  타임슬롯 50개, 참가자 20명 기준:</p>
<ul>
<li>데이터베이스 쿼리: 약 50~100번</li>
<li>처리 시간: &lt; 100ms</li>
</ul>